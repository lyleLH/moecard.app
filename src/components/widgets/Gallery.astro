---
import { Image } from 'astro:assets';

interface Props {
  title?: string;
  subtitle?: string;
  images: {
    src: any;
    alt: string;
  }[];
  classes?: {
    container?: string;
    title?: string;
    subtitle?: string;
    grid?: string;
  };
}

const {
  title = '',
  subtitle = '',
  images = [],
  classes = {},
} = Astro.props;

// 将图片分成两组，并限制每组最多显示6张图片
const firstRow = images.filter((_, i) => i % 2 === 0).slice(0, 6);
const secondRow = images.filter((_, i) => i % 2 === 1).slice(0, 6);

// 生成缩略图尺寸
const thumbnailWidth = 320;
const thumbnailHeight = Math.floor(thumbnailWidth * 4/3);
---

<section class:list={['relative', classes?.container]}>
  <div class="max-w-7xl mx-auto px-4 sm:px-6">
    {title && (
      <h2 class:list={['text-center mb-4', classes?.title]}>
        {title}
      </h2>
    )}
    {subtitle && (
      <p class:list={['text-center mb-12', classes?.subtitle]}>
        {subtitle}
      </p>
    )}
    
    <div class="space-y-8">
      <!-- 第一行 向左滚动 -->
      <div class="overflow-hidden">
        <div class="scroll-row flex gap-4 animate-scroll-left">
          {[...firstRow, ...firstRow].map((image) => (
            <div 
              class="relative group w-[320px] flex-shrink-0 overflow-hidden rounded-2xl shadow-md hover:shadow-xl transition-all duration-300 cursor-pointer gallery-item"
              data-src={image.src.src}
            >
              <div class="aspect-[3/4]">
                <Image
                  src={image.src}
                  alt={image.alt}
                  width={thumbnailWidth}
                  height={thumbnailHeight}
                  class="w-full h-full object-cover hover:scale-105 transition-transform duration-300"
                  loading="eager"
                  decoding="async"
                  quality={60}
                />
                <div class="absolute inset-0 bg-black opacity-0 group-hover:opacity-20 transition-opacity duration-300"></div>
              </div>
            </div>
          ))}
        </div>
      </div>

      <!-- 第二行 向右滚动 -->
      <div class="overflow-hidden">
        <div class="scroll-row flex gap-4 animate-scroll-right">
          {[...secondRow, ...secondRow].map((image) => (
            <div 
              class="relative group w-[320px] flex-shrink-0 overflow-hidden rounded-2xl shadow-md hover:shadow-xl transition-all duration-300 cursor-pointer gallery-item"
              data-src={image.src.src}
            >
              <div class="aspect-[3/4]">
                <Image
                  src={image.src}
                  alt={image.alt}
                  width={thumbnailWidth}
                  height={thumbnailHeight}
                  class="w-full h-full object-cover hover:scale-105 transition-transform duration-300"
                  loading="lazy"
                  decoding="async"
                  quality={60}
                />
                <div class="absolute inset-0 bg-black opacity-0 group-hover:opacity-20 transition-opacity duration-300"></div>
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  </div>

  <!-- 全屏查看模态框 -->
  <div id="imageModal" class="fixed inset-0 bg-black bg-opacity-90 z-50 hidden items-center justify-center">
    <button class="absolute top-4 right-4 text-white text-4xl hover:text-gray-300" id="closeModal">&times;</button>
    <div class="relative w-full h-full flex items-center justify-center">
      <img id="modalImage" class="max-h-[90vh] max-w-[90vw] object-contain opacity-0 transition-opacity duration-300" src="" alt="Full screen image" />
      <button class="absolute left-4 top-1/2 transform -translate-y-1/2 text-white text-4xl hover:text-gray-300" id="prevImage">&lt;</button>
      <button class="absolute right-4 top-1/2 transform -translate-y-1/2 text-white text-4xl hover:text-gray-300" id="nextImage">&gt;</button>
      <div id="loadingIndicator" class="hidden absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
        <div class="animate-spin rounded-full h-12 w-12 border-4 border-white border-t-transparent"></div>
      </div>
    </div>
  </div>
</section>

<style>
  @keyframes scrollLeft {
    0% {
      transform: translateX(0);
    }
    100% {
      transform: translateX(calc(-320px * 6 - 1rem * 6));
    }
  }

  @keyframes scrollRight {
    0% {
      transform: translateX(calc(-320px * 6 - 1rem * 6));
    }
    100% {
      transform: translateX(0);
    }
  }

  .animate-scroll-left {
    animation: scrollLeft 30s linear infinite;
    will-change: transform;
  }

  .animate-scroll-right {
    animation: scrollRight 30s linear infinite;
    will-change: transform;
  }

  .scroll-row:hover {
    animation-play-state: paused;
  }

  .scroll-row {
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
  }
</style>

<script>
  let currentImageIndex = 0;
  let allImages: string[] = [];
  const preloadedImages: { [key: string]: HTMLImageElement } = {};

  // 预加载图片函数
  function preloadImage(src: string): Promise<HTMLImageElement> {
    if (preloadedImages[src]) {
      return Promise.resolve(preloadedImages[src]);
    }

    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        preloadedImages[src] = img;
        resolve(img);
      };
      img.onerror = reject;
      img.src = src;
    });
  }

  // 预加载相邻图片
  function preloadAdjacentImages(currentIndex: number) {
    const nextIndex = (currentIndex + 1) % allImages.length;
    const prevIndex = (currentIndex - 1 + allImages.length) % allImages.length;
    
    Promise.all([
      preloadImage(allImages[nextIndex]),
      preloadImage(allImages[prevIndex])
    ]).catch(console.error);
  }

  document.addEventListener('DOMContentLoaded', () => {
    const modal = document.getElementById('imageModal') as HTMLDivElement;
    const modalImg = document.getElementById('modalImage') as HTMLImageElement;
    const loadingIndicator = document.getElementById('loadingIndicator') as HTMLDivElement;
    const closeBtn = document.getElementById('closeModal') as HTMLButtonElement;
    const prevBtn = document.getElementById('prevImage') as HTMLButtonElement;
    const nextBtn = document.getElementById('nextImage') as HTMLButtonElement;
    const galleryItems = document.querySelectorAll('.gallery-item');

    // 收集所有图片URL
    allImages = Array.from(galleryItems)
      .map(item => item.getAttribute('data-src'))
      .filter((src): src is string => src !== null);

    async function showImage(index: number) {
      currentImageIndex = index;
      if (modalImg && index >= 0 && index < allImages.length) {
        loadingIndicator.classList.remove('hidden');
        modalImg.classList.add('opacity-0');
        
        try {
          const img = await preloadImage(allImages[index]);
          modalImg.src = img.src;
          modalImg.classList.remove('opacity-0');
          preloadAdjacentImages(index);
        } catch (error) {
          console.error('Failed to load image:', error);
        } finally {
          loadingIndicator.classList.add('hidden');
        }
      }
    }

    function showNextImage() {
      showImage((currentImageIndex + 1) % allImages.length);
    }

    function showPrevImage() {
      showImage((currentImageIndex - 1 + allImages.length) % allImages.length);
    }

    if (modal && modalImg && closeBtn && prevBtn && nextBtn) {
      galleryItems.forEach((item, index) => {
        item.addEventListener('click', () => {
          modal.classList.remove('hidden');
          modal.classList.add('flex');
          document.body.style.overflow = 'hidden';
          showImage(index);
        });
      });

      closeBtn.addEventListener('click', () => {
        modal.classList.add('hidden');
        modal.classList.remove('flex');
        document.body.style.overflow = '';
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.classList.add('hidden');
          modal.classList.remove('flex');
          document.body.style.overflow = '';
        }
      });

      prevBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        showPrevImage();
      });

      nextBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        showNextImage();
      });

      // 键盘控制
      document.addEventListener('keydown', (e) => {
        if (!modal.classList.contains('hidden')) {
          switch(e.key) {
            case 'Escape':
              modal.classList.add('hidden');
              modal.classList.remove('flex');
              document.body.style.overflow = '';
              break;
            case 'ArrowLeft':
              showPrevImage();
              break;
            case 'ArrowRight':
              showNextImage();
              break;
          }
        }
      });
    }
  });

  // 使用 Intersection Observer 优化滚动性能
  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach(entry => {
        const row = entry.target as HTMLElement;
        if (entry.isIntersecting) {
          row.style.animationPlayState = 'running';
        } else {
          row.style.animationPlayState = 'paused';
        }
      });
    },
    { threshold: 0.1 }
  );

  document.querySelectorAll('.scroll-row').forEach(row => {
    observer.observe(row);
    
    row.addEventListener('mouseenter', () => {
      (row as HTMLElement).style.animationPlayState = 'paused';
    });
    
    row.addEventListener('mouseleave', () => {
      (row as HTMLElement).style.animationPlayState = 'running';
    });
  });
</script>